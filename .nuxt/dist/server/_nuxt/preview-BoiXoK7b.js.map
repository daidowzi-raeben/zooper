{"version":3,"file":"preview-BoiXoK7b.js","sources":["../../../../node_modules/nuxt/dist/app/composables/cookie.js","../../../../node_modules/@nuxt/content/dist/runtime/composables/preview.js"],"sourcesContent":["import { customRef, getCurrentScope, nextTick, onScopeDispose, ref, watch } from \"vue\";\nimport { parse, serialize } from \"cookie-es\";\nimport { deleteCookie, getCookie, getRequestHeader, setCookie } from \"h3\";\nimport destr from \"destr\";\nimport { isEqual } from \"ohash\";\nimport { klona } from \"klona\";\nimport { useNuxtApp } from \"../nuxt.js\";\nimport { useRequestEvent } from \"./ssr.js\";\nconst CookieDefaults = {\n  path: \"/\",\n  watch: true,\n  decode: (val) => destr(decodeURIComponent(val)),\n  encode: (val) => encodeURIComponent(typeof val === \"string\" ? val : JSON.stringify(val))\n};\nexport function useCookie(name, _opts) {\n  const opts = { ...CookieDefaults, ..._opts };\n  const cookies = readRawCookies(opts) || {};\n  let delay;\n  if (opts.maxAge !== void 0) {\n    delay = opts.maxAge * 1e3;\n  } else if (opts.expires) {\n    delay = opts.expires.getTime() - Date.now();\n  }\n  const hasExpired = delay !== void 0 && delay <= 0;\n  const cookieValue = klona(hasExpired ? void 0 : cookies[name] ?? opts.default?.());\n  const cookie = import.meta.client && delay && !hasExpired ? cookieRef(cookieValue, delay) : ref(cookieValue);\n  if (import.meta.dev && hasExpired) {\n    console.warn(`[nuxt] not setting cookie \\`${name}\\` as it has already expired.`);\n  }\n  if (import.meta.client) {\n    const channel = typeof BroadcastChannel === \"undefined\" ? null : new BroadcastChannel(`nuxt:cookies:${name}`);\n    const callback = () => {\n      if (opts.readonly || isEqual(cookie.value, cookies[name])) {\n        return;\n      }\n      writeClientCookie(name, cookie.value, opts);\n      channel?.postMessage(opts.encode(cookie.value));\n    };\n    let watchPaused = false;\n    if (getCurrentScope()) {\n      onScopeDispose(() => {\n        watchPaused = true;\n        callback();\n        channel?.close();\n      });\n    }\n    if (channel) {\n      channel.onmessage = (event) => {\n        watchPaused = true;\n        cookies[name] = cookie.value = opts.decode(event.data);\n        nextTick(() => {\n          watchPaused = false;\n        });\n      };\n    }\n    if (opts.watch) {\n      watch(\n        cookie,\n        () => {\n          if (watchPaused) {\n            return;\n          }\n          callback();\n        },\n        { deep: opts.watch !== \"shallow\" }\n      );\n    } else {\n      callback();\n    }\n  } else if (import.meta.server) {\n    const nuxtApp = useNuxtApp();\n    const writeFinalCookieValue = () => {\n      if (opts.readonly || isEqual(cookie.value, cookies[name])) {\n        return;\n      }\n      writeServerCookie(useRequestEvent(nuxtApp), name, cookie.value, opts);\n    };\n    const unhook = nuxtApp.hooks.hookOnce(\"app:rendered\", writeFinalCookieValue);\n    nuxtApp.hooks.hookOnce(\"app:error\", () => {\n      unhook();\n      return writeFinalCookieValue();\n    });\n  }\n  return cookie;\n}\nfunction readRawCookies(opts = {}) {\n  if (import.meta.server) {\n    return parse(getRequestHeader(useRequestEvent(), \"cookie\") || \"\", opts);\n  } else if (import.meta.client) {\n    return parse(document.cookie, opts);\n  }\n}\nfunction serializeCookie(name, value, opts = {}) {\n  if (value === null || value === void 0) {\n    return serialize(name, value, { ...opts, maxAge: -1 });\n  }\n  return serialize(name, value, opts);\n}\nfunction writeClientCookie(name, value, opts = {}) {\n  if (import.meta.client) {\n    document.cookie = serializeCookie(name, value, opts);\n  }\n}\nfunction writeServerCookie(event, name, value, opts = {}) {\n  if (event) {\n    if (value !== null && value !== void 0) {\n      return setCookie(event, name, value, opts);\n    }\n    if (getCookie(event, name) !== void 0) {\n      return deleteCookie(event, name, opts);\n    }\n  }\n}\nconst MAX_TIMEOUT_DELAY = 2147483647;\nfunction cookieRef(value, delay) {\n  let timeout;\n  let elapsed = 0;\n  if (getCurrentScope()) {\n    onScopeDispose(() => {\n      clearTimeout(timeout);\n    });\n  }\n  return customRef((track, trigger) => {\n    function createExpirationTimeout() {\n      clearTimeout(timeout);\n      const timeRemaining = delay - elapsed;\n      const timeoutLength = timeRemaining < MAX_TIMEOUT_DELAY ? timeRemaining : MAX_TIMEOUT_DELAY;\n      timeout = setTimeout(() => {\n        elapsed += timeoutLength;\n        if (elapsed < delay) {\n          return createExpirationTimeout();\n        }\n        value = void 0;\n        trigger();\n      }, timeoutLength);\n    }\n    return {\n      get() {\n        track();\n        return value;\n      },\n      set(newValue) {\n        createExpirationTimeout();\n        value = newValue;\n        trigger();\n      }\n    };\n  });\n}\n","import { useCookie, useRoute } from \"#imports\";\nlet showWarning = true;\nexport const useContentPreview = () => {\n  const getPreviewToken = () => {\n    return useCookie(\"previewToken\").value || import.meta.client && sessionStorage.getItem(\"previewToken\") || void 0;\n  };\n  const setPreviewToken = (token) => {\n    useCookie(\"previewToken\").value = token;\n    useRoute().query.preview = token || \"\";\n    if (import.meta.client) {\n      if (token) {\n        sessionStorage.setItem(\"previewToken\", token);\n      } else {\n        sessionStorage.removeItem(\"previewToken\");\n      }\n      window.location.reload();\n    }\n  };\n  const isEnabled = () => {\n    const query = useRoute().query;\n    if (Object.prototype.hasOwnProperty.call(query, \"preview\") && !query.preview) {\n      return false;\n    }\n    if (query.preview || useCookie(\"previewToken\").value) {\n      if (import.meta.dev && showWarning) {\n        console.warn(\"[content] Client DB enabled since a preview token is set (either in query or cookie).\");\n        showWarning = false;\n      }\n      return true;\n    }\n    if (import.meta.client && sessionStorage.getItem(\"previewToken\")) {\n      return true;\n    }\n    return false;\n  };\n  return {\n    isEnabled,\n    getPreviewToken,\n    setPreviewToken\n  };\n};\n"],"names":[],"mappings":";;;;;;;;AAQA,MAAM,iBAAiB;AAAA,EACrB,MAAM;AAAA,EACN,OAAO;AAAA,EACP,QAAQ,CAAC,QAAQ,MAAM,mBAAmB,GAAG,CAAC;AAAA,EAC9C,QAAQ,CAAC,QAAQ,mBAAmB,OAAO,QAAQ,WAAW,MAAM,KAAK,UAAU,GAAG,CAAC;AACzF;AACgB,SAAA,UAAU,MAAM,OAAO;;AACrC,QAAM,OAAO,EAAE,GAAG,gBAAgB,GAAG,MAAM;AAC3C,QAAM,UAAU,eAAe,IAAI,KAAK,CAAC;AACrC,MAAA;AACA,MAAA,KAAK,WAAW,QAAQ;AAC1B,YAAQ,KAAK,SAAS;AAAA,EAAA,WACb,KAAK,SAAS;AACvB,YAAQ,KAAK,QAAQ,QAAQ,IAAI,KAAK,IAAI;AAAA,EAAA;AAEtC,QAAA,aAAa,UAAU,UAAU,SAAS;AAC1C,QAAA,cAAc,MAAM,aAAa,SAAS,QAAQ,IAAI,OAAK,UAAK,YAAL,8BAAgB;AACjF,QAAM,SAAsF,IAAI,WAAW;AA4C5E;AAC7B,UAAM,UAAU,WAAW;AAC3B,UAAM,wBAAwB,MAAM;AAC9B,UAAA,KAAK,YAAY,QAAQ,OAAO,OAAO,QAAQ,IAAI,CAAC,GAAG;AACzD;AAAA,MAAA;AAEF,wBAAkB,gBAAgB,OAAO,GAAG,MAAM,OAAO,OAAO,IAAI;AAAA,IACtE;AACA,UAAM,SAAS,QAAQ,MAAM,SAAS,gBAAgB,qBAAqB;AACnE,YAAA,MAAM,SAAS,aAAa,MAAM;AACjC,aAAA;AACP,aAAO,sBAAsB;AAAA,IAAA,CAC9B;AAAA,EAAA;AAEI,SAAA;AACT;AACA,SAAS,eAAe,OAAO,IAAI;AACT;AACtB,WAAO,MAAM,iBAAiB,gBAAA,GAAmB,QAAQ,KAAK,IAAI,IAAI;AAAA,EAAA;AAI1E;AAYA,SAAS,kBAAkB,OAAO,MAAM,OAAO,OAAO,CAAA,GAAI;AACxD,MAAI,OAAO;AACL,QAAA,UAAU,QAAQ,UAAU,QAAQ;AACtC,aAAO,UAAU,OAAO,MAAM,OAAO,IAAI;AAAA,IAAA;AAE3C,QAAI,UAAU,OAAO,IAAI,MAAM,QAAQ;AAC9B,aAAA,aAAa,OAAO,MAAM,IAAI;AAAA,IAAA;AAAA,EACvC;AAEJ;AC9GO,MAAM,oBAAoB,MAAM;AACrC,QAAM,kBAAkB,MAAM;AAC5B,WAAO,UAAU,cAAc,EAAE,SAAS,SAAgE;AAAA,EAC5G;AACM,QAAA,kBAAkB,CAAC,UAAU;AACvB,cAAA,cAAc,EAAE,QAAQ;AACzB,eAAE,MAAM,UAAU,SAAS;AAAA,EAStC;AACA,QAAM,YAAY,MAAM;AAChB,UAAA,QAAQ,WAAW;AACrB,QAAA,OAAO,UAAU,eAAe,KAAK,OAAO,SAAS,KAAK,CAAC,MAAM,SAAS;AACrE,aAAA;AAAA,IAAA;AAET,QAAI,MAAM,WAAW,UAAU,cAAc,EAAE,OAAO;AAK7C,aAAA;AAAA,IAAA;AAKF,WAAA;AAAA,EACT;AACO,SAAA;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;","x_google_ignoreList":[0,1]}